Purpose
This program solves the Job Shop Scheduling Problem using a sequential Branch & Bound approach. The goal is to schedule a set of jobs (each with a sequence of operations on specific machines) to minimize the total completion time (makespan).

Key Components

1. Data Structures
operations: Stores, for each job and operation, the machine it runs on and its duration.
Node: Represents a partial schedule (state) in the search tree, including:
start_times: When each operation starts.
job_time: When each job is next available.
machine_time: When each machine is next available.
depth: How many operations have been scheduled.
job_pool: Stack of nodes for exploring the search tree.

2. Input
Reads the number of jobs and machines.
For each job and operation, reads the machine and duration.

3. Branch & Bound Algorithm
Initialization: Start with an empty schedule (root node).
Main Loop: While there are nodes in the pool:
Pop a node (partial schedule).
If all operations are scheduled (depth == num_jobs * num_machines):
Compute the makespan (maximum job finish time).
If it’s better than the best found, update the best solution.
Else:
Determine the next operation to schedule.
Find the earliest start time for this operation (no conflicts on the machine).
Create a child node with this operation scheduled.
Add the child to the pool if there’s space.

4. Conflict Checking
is_conflict: Checks if scheduling an operation on a machine at a given time overlaps with any already scheduled operation on that machine.
5. Output
Writes the best makespan and the start times for all operations to an output file.
Writes execution time and makespan to a metrics file.


Summary of the Algorithm
Read input: Parse jobs, machines, and operations.
Initialize root node: No operations scheduled.
Branch & Bound search:
At each step, schedule the next operation for a job.
Use conflict checking to ensure no two operations overlap on the same machine.
Track the best makespan found.
Output results: Best schedule and performance metrics.
Notes
The algorithm is sequential (single-threaded).
Uses a simple stack-based search (DFS).
No advanced pruning or heuristics—explores all possible schedules up to MAX_NODES.
If you want a more detailed explanation of any function or part, let me know!