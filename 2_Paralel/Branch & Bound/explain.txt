Purpose
This program solves the Job Shop Scheduling Problem using a parallel Branch & Bound approach with POSIX threads (pthreads). The goal is to minimize the makespan (total completion time) by efficiently scheduling jobs with multiple threads.

Key Components
1. Data Structures
operations: Stores, for each job and operation, the machine it runs on and its duration.
Node: Represents a partial schedule (state) in the search tree, including:
start_times: When each operation starts.
job_time: When each job is next available.
machine_time: When each machine is next available.
depth: How many operations have been scheduled.
job_pool: Shared queue of nodes for exploring the search tree (BFS-like).
front/rear: Indices for the job pool queue.

2. Parallelism
Uses pthreads to run multiple threads.
Mutex (pthread_mutex_t mutex) protects shared data (job pool, best solution).

3. Input
Reads the number of jobs and machines.
For each job and operation, reads the machine and duration.

4. Branch & Bound Algorithm (Parallel)
Initialization: Start with an empty schedule (root node) in the job pool.
Threads: Each thread repeatedly:
Locks the mutex and pops a node from the job pool.
If all operations are scheduled:
Computes the makespan.
Updates the best solution if improved (mutex protected).
Else:
Schedules the next operation for a job.
Finds the earliest start time (no conflicts on the machine).
Prunes if the estimated end time is not better than the current best.
Adds the new child node to the job pool (mutex protected).
Threads exit when the job pool is empty.

5. Conflict Checking
is_conflict: Checks if scheduling an operation on a machine at a given time overlaps with any already scheduled operation on that machine.

6. Output
Writes the best makespan and the start times for all operations to an output file.
Writes execution time and makespan to a metrics file.

Summary of the Algorithm
Read input: Parse jobs, machines, and operations.
Initialize root node: No operations scheduled.
Parallel Branch & Bound search:
Multiple threads pop nodes from the shared pool.
At each step, schedule the next operation for a job.
Use conflict checking to ensure no two operations overlap on the same machine.
Prune branches that cannot improve the best makespan.
Track the best makespan found.
Output results: Best schedule and performance metrics.
Notes
The algorithm is parallelized using pthreads for faster exploration.
Uses a queue (BFS-like) for the job pool, not a stack.
Mutexes ensure thread safety for shared data.
Prunes branches that cannot improve the best makespan.
If you want a more detailed explanation of any function or part, let me know!